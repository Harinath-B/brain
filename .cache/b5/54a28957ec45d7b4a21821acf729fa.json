{"id":"a8Dh","dependencies":[{"name":"/home/hari/Desktop/mystery-ai/brain/package.json","includedInParent":true,"mtime":1704390744954},{"name":"/home/hari/Desktop/mystery-ai/brain/node_modules/troika-three-utils/package.json","includedInParent":true,"mtime":1704390697242},{"name":"three","loc":{"line":1,"column":204,"index":204},"parent":"/home/hari/Desktop/mystery-ai/brain/node_modules/troika-three-utils/dist/troika-three-utils.esm.js","resolved":"/home/hari/Desktop/mystery-ai/brain/node_modules/three/build/three.module.js"}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.createDerivedMaterial=u,exports.expandShaderIncludes=n,exports.getShaderUniformTypes=b,exports.getShadersForMaterial=g,exports.invertMatrix4=x,exports.voidMainRegExp=exports.BezierMesh=void 0;var e=require(\"three\");const t=/\\bvoid\\s+main\\s*\\(\\s*\\)\\s*{/g;function n(t){return t.replace(/^[ \\t]*#include +<([\\w\\d./]+)>/gm,function(t,i){let r=e.ShaderChunk[i];return r?n(r):t})}exports.voidMainRegExp=t;const i=[];for(let A=0;A<256;A++)i[A]=(A<16?\"0\":\"\")+A.toString(16);function r(){const e=4294967295*Math.random()|0,t=4294967295*Math.random()|0,n=4294967295*Math.random()|0,r=4294967295*Math.random()|0;return(i[255&e]+i[e>>8&255]+i[e>>16&255]+i[e>>24&255]+\"-\"+i[255&t]+i[t>>8&255]+\"-\"+i[t>>16&15|64]+i[t>>24&255]+\"-\"+i[63&n|128]+i[n>>8&255]+\"-\"+i[n>>16&255]+i[n>>24&255]+i[255&r]+i[r>>8&255]+i[r>>16&255]+i[r>>24&255]).toUpperCase()}const a=Object.assign||function(){let e=arguments[0];for(let t=1,n=arguments.length;t<n;t++){let n=arguments[t];if(n)for(let t in n)n.hasOwnProperty(t)&&(e[t]=n[t])}return e},o=Date.now(),s=new WeakMap,c=new Map;let l=1e10;function u(t,n){const i=m(n);let f=s.get(t);if(f||s.set(t,f=Object.create(null)),f[i])return new f[i];const h=`_onBeforeCompile${i}`,p=function(e){t.onBeforeCompile.call(this,e);const r=this.customProgramCacheKey()+\"|\"+e.vertexShader+\"|\"+e.fragmentShader;let s=c[r];if(!s){const t=d(e,n,i);s=c[r]=t}e.vertexShader=s.vertexShader,e.fragmentShader=s.fragmentShader,a(e.uniforms,this.uniforms),n.timeUniform&&(e.uniforms[n.timeUniform]={get value(){return Date.now()-o}}),this[h]&&this[h](e)},v=function(){return M(n.chained?t:t.clone())},M=function(e){const o=Object.create(e,g);return Object.defineProperty(o,\"baseMaterial\",{value:t}),Object.defineProperty(o,\"id\",{value:l++}),o.uuid=r(),o.uniforms=a({},e.uniforms,n.uniforms),o.defines=a({},e.defines,n.defines),o.defines[`TROIKA_DERIVED_MATERIAL_${i}`]=\"\",o.extensions=a({},e.extensions,n.extensions),o._listeners=void 0,o},g={constructor:{value:v},isDerivedMaterial:{value:!0},customProgramCacheKey:{writable:!0,configurable:!0,value:function(){return t.customProgramCacheKey()+\"|\"+i}},onBeforeCompile:{get:()=>p,set(e){this[h]=e}},copy:{writable:!0,configurable:!0,value:function(n){return t.copy.call(this,n),t.isShaderMaterial||t.isDerivedMaterial||(a(this.extensions,n.extensions),a(this.defines,n.defines),a(this.uniforms,e.UniformsUtils.clone(n.uniforms))),this}},clone:{writable:!0,configurable:!0,value:function(){const e=new t.constructor;return M(e).copy(this)}},getDepthMaterial:{writable:!0,configurable:!0,value:function(){let i=this._depthMaterial;return i||((i=this._depthMaterial=u(t.isDerivedMaterial?t.getDepthMaterial():new e.MeshDepthMaterial({depthPacking:e.RGBADepthPacking}),n)).defines.IS_DEPTH_MATERIAL=\"\",i.uniforms=this.uniforms),i}},getDistanceMaterial:{writable:!0,configurable:!0,value:function(){let i=this._distanceMaterial;return i||((i=this._distanceMaterial=u(t.isDerivedMaterial?t.getDistanceMaterial():new e.MeshDistanceMaterial,n)).defines.IS_DISTANCE_MATERIAL=\"\",i.uniforms=this.uniforms),i}},dispose:{writable:!0,configurable:!0,value(){const{_depthMaterial:e,_distanceMaterial:n}=this;e&&e.dispose(),n&&n.dispose(),t.dispose.call(this)}}};return f[i]=v,new v}function d({vertexShader:e,fragmentShader:t},i,r){let{vertexDefs:a,vertexMainIntro:o,vertexMainOutro:s,vertexTransform:c,fragmentDefs:l,fragmentMainIntro:u,fragmentMainOutro:d,fragmentColorTransform:h,customRewriter:p,timeUniform:v}=i;if(a=a||\"\",o=o||\"\",s=s||\"\",l=l||\"\",u=u||\"\",d=d||\"\",(c||p)&&(e=n(e)),(h||p)&&(t=n(t=t.replace(/^[ \\t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,\"\\n//!BEGIN_POST_CHUNK $1\\n$&\\n//!END_POST_CHUNK\\n\"))),p){let n=p({vertexShader:e,fragmentShader:t});e=n.vertexShader,t=n.fragmentShader}if(h){let e=[];t=t.replace(/^\\/\\/!BEGIN_POST_CHUNK[^]+?^\\/\\/!END_POST_CHUNK/gm,t=>(e.push(t),\"\")),d=`${h}\\n${e.join(\"\\n\")}\\n${d}`}if(v){const e=`\\nuniform float ${v};\\n`;a=e+a,l=e+l}return c&&(a=`${a}\\nvoid troikaVertexTransform${r}(inout vec3 position, inout vec3 normal, inout vec2 uv) {\\n  ${c}\\n}\\n`,o=`\\ntroika_position_${r} = vec3(position);\\ntroika_normal_${r} = vec3(normal);\\ntroika_uv_${r} = vec2(uv);\\ntroikaVertexTransform${r}(troika_position_${r}, troika_normal_${r}, troika_uv_${r});\\n${o}\\n`,e=(e=`vec3 troika_position_${r};\\nvec3 troika_normal_${r};\\nvec2 troika_uv_${r};\\n${e}\\n`).replace(/\\b(position|normal|uv)\\b/g,(e,t,n,i)=>/\\battribute\\s+vec[23]\\s+$/.test(i.substr(0,n))?t:`troika_${t}_${r}`)),{vertexShader:e=f(e,r,a,o,s),fragmentShader:t=f(t,r,l,u,d)}}function f(e,n,i,r,a){return(r||a||i)&&(e=e.replace(t,`\\n${i}\\nvoid troikaOrigMain${n}() {`),e+=`\\nvoid main() {\\n  ${r}\\n  troikaOrigMain${n}();\\n  ${a}\\n}`),e}function h(e,t){return\"uniforms\"===e?void 0:\"function\"==typeof t?t.toString():t}let p=0;const v=new Map;function m(e){const t=JSON.stringify(e,h);let n=v.get(t);return null==n&&v.set(t,n=++p),n}const M={MeshDepthMaterial:\"depth\",MeshDistanceMaterial:\"distanceRGBA\",MeshNormalMaterial:\"normal\",MeshBasicMaterial:\"basic\",MeshLambertMaterial:\"lambert\",MeshPhongMaterial:\"phong\",MeshToonMaterial:\"toon\",MeshStandardMaterial:\"physical\",MeshPhysicalMaterial:\"physical\",MeshMatcapMaterial:\"matcap\",LineBasicMaterial:\"basic\",LineDashedMaterial:\"dashed\",PointsMaterial:\"points\",ShadowMaterial:\"shadow\",SpriteMaterial:\"sprite\"};function g(t){let n=M[t.type];return n?e.ShaderLib[n]:t}function b(e){let t,n=/\\buniform\\s+(int|float|vec[234])\\s+([A-Za-z_][\\w]*)/g,i=Object.create(null);for(;null!==(t=n.exec(e));)i[t[2]]=t[1];return i}function x(t,n=new e.Matrix4){return\"function\"==typeof n.invert?n.copy(t).invert():n.getInverse(t),n}const _=\"\\nuniform vec3 pointA;\\nuniform vec3 controlA;\\nuniform vec3 controlB;\\nuniform vec3 pointB;\\nuniform float radius;\\nvarying float bezierT;\\n\\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\\n  float t2 = 1.0 - t;\\n  float b0 = t2 * t2 * t2;\\n  float b1 = 3.0 * t * t2 * t2;\\n  float b2 = 3.0 * t * t * t2;\\n  float b3 = t * t * t;\\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\\n}\\n\\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\\n  float t2 = 1.0 - t;\\n  return -3.0 * p1 * t2 * t2 +\\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\\n    3.0 * p2 * t * t;\\n}\\n\",y='\\nfloat t = position.y;\\nbezierT = t;\\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\\n\\n// Make \"sideways\" always perpendicular to the camera ray; this ensures that any twists\\n// in the cylinder occur where you won\\'t see them: \\nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\\nif (bezierDir == viewDirection) {\\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\\n}\\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\\nvec3 upish = normalize(cross(sideways, bezierDir));\\n\\n// Build a matrix for transforming this disc in the cylinder:\\nmat4 discTx;\\ndiscTx[0].xyz = sideways * radius;\\ndiscTx[1].xyz = bezierDir * radius;\\ndiscTx[2].xyz = upish * radius;\\ndiscTx[3].xyz = bezierCenterPos;\\ndiscTx[3][3] = 1.0;\\n\\n// Apply transform, ignoring original y\\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\\nnormal = normalize(mat3(discTx) * normal);\\n',w=\"\\nuniform vec3 dashing;\\nvarying float bezierT;\\n\",D=\"\\nif (dashing.x + dashing.y > 0.0) {\\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\\n  if (dashFrac > dashing.x) {\\n    discard;\\n  }\\n}\\n\";function B(t){return u(t,{chained:!0,uniforms:{pointA:{value:new e.Vector3},controlA:{value:new e.Vector3},controlB:{value:new e.Vector3},pointB:{value:new e.Vector3},radius:{value:.01},dashing:{value:new e.Vector3}},vertexDefs:_,vertexTransform:y,fragmentDefs:w,fragmentMainIntro:D})}let S=null;const z=new e.MeshStandardMaterial({color:16777215,side:e.DoubleSide});class $ extends e.Mesh{static getGeometry(){return S||(S=new e.CylinderBufferGeometry(1,1,1,6,64).translate(0,.5,0))}constructor(){super($.getGeometry(),z),this.pointA=new e.Vector3,this.controlA=new e.Vector3,this.controlB=new e.Vector3,this.pointB=new e.Vector3,this.radius=.01,this.dashArray=new e.Vector2,this.dashOffset=0,this.frustumCulled=!1}get material(){let e=this._derivedMaterial;const t=this._baseMaterial||this._defaultMaterial||(this._defaultMaterial=z.clone());return e&&e.baseMaterial===t||(e=this._derivedMaterial=B(t),t.addEventListener(\"dispose\",function n(){t.removeEventListener(\"dispose\",n),e.dispose()})),e}set material(e){this._baseMaterial=e}get customDepthMaterial(){return this.material.getDepthMaterial()}get customDistanceMaterial(){return this.material.getDistanceMaterial()}onBeforeRender(e){const{uniforms:t}=this.material,{pointA:n,controlA:i,controlB:r,pointB:a,radius:o,dashArray:s,dashOffset:c}=this;t.pointA.value.copy(n),t.controlA.value.copy(i),t.controlB.value.copy(r),t.pointB.value.copy(a),t.radius.value=o,t.dashing.value.set(s.x,s.y,c||0)}raycast(e,t){}}exports.BezierMesh=$;"},"sourceMaps":null,"error":null,"hash":"4ed8152aa7615bd67e279daa07866ab1","cacheData":{"env":{}}}